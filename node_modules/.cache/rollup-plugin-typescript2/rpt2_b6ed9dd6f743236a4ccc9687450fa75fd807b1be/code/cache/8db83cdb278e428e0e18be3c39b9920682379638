{"code":"import { isArray } from \"@iVue/shared\";\r\nexport var effect = function (fn, options) {\r\n    // 需要让传递来的fn 变成响应式的effect，数据有变化 这个fn就能重新执行\r\n    var effect = createReactiveEffect(fn, options); //fn用户传递的函数\r\n    if (!options || (options && !options.lazy)) {\r\n        effect();\r\n    }\r\n    return effect;\r\n};\r\n// effect 应该和数据关联起来\r\nexport var effectStack = []; // 这个栈为了保证当前effect 和属性能对应上\r\nexport var activeEffect = null;\r\nvar id = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    var effect = function reactiveEffect() {\r\n        if (!effectStack.includes(effect)) { // 不要放重复的effect，防止死循环\r\n            try {\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn(); // 让函数执行, 执行完毕后才会执行后面\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = id++;\r\n    effect.options = options;\r\n    return effect;\r\n}\r\n// 某个对象中的 某个属性依赖了哪些些effect\r\n// {{}:{name:[effect,effect]}}\r\n// 对象是key使用map，防止内存泄露用 wekMap\r\nvar targetMap = new WeakMap(); // 收集被劫持的对象\r\n// 收集effect依赖\r\nexport function track(target, key) {\r\n    if (activeEffect === undefined)\r\n        return;\r\n    var depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // 给targetmap添加一条记录\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    var dep = depsMap.get(key);\r\n    if (!dep) { // 收集effect\r\n        // 给对象的某个属性创建一个set属性用户存放effect回调函数，不能重复\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect); // 收集effect，给该对象的属性增加一条effect，下次更新会通知所以effect更新。\r\n    }\r\n}\r\n// 触发某个对象的某个属性的set或add操作\r\nexport function trigger(target, type, key, value) {\r\n    var depsMap = targetMap.get(target);\r\n    if (!depsMap)\r\n        return; // 属性变了但是没有依赖收集，直接跳过\r\n    // 修改\r\n    if (key !== undefined) {\r\n        var effects = depsMap.get(key); // set的对象\r\n        run(effects);\r\n        return;\r\n    }\r\n    if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach(function (dep, k) {\r\n            // 如果改变了长度要更新，小于之前的值也要更新\r\n            if (k >= value) {\r\n                run(dep);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    switch (type) {\r\n        case 'add': // 添加属性就触发\r\n            // arr.push\r\n            if (isArray(target)) {\r\n                if (parseInt(key) == key) {\r\n                    run(depsMap.get('length'));\r\n                }\r\n            }\r\n            break;\r\n        case 'set':\r\n            break;\r\n        default:\r\n    }\r\n}\r\n// 执行effect\r\nfunction run(effects) {\r\n    effects && effects.forEach(function (effect) {\r\n        // effect 有两种 1.渲染 2.计算属性对应的effect\r\n        // 计算属性\r\n        if (!effect)\r\n            return;\r\n        if (effect.options && effect.options.scheduler) {\r\n            effect.options.scheduler();\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    });\r\n}\r\n// effect1(()=>{\r\n//     state.name\r\n//     effect2(()=>{\r\n//         state.age\r\n//     })\r\n//     state.address\r\n// })\r\n// 默认先调用effect1 内部对state.name取值 ， 把name属性和 activeEffect(effect1) 关联起来\r\n// 调用effect2 内部对state.age取值， 把age 和 activeEffect(effect2) 关联起来\r\n// effect2 执行完毕 activeEffect 指向effect1\r\n// state.address 再次取值 此时关联到了 effect1\r\n// 数据变化effect就会重新执行\r\n// effect(()=>{\r\n//     state.name++;\r\n// })\r\n","references":["/Users/bingyang/Documents/festudy/my-vue3/packages/shared/src/index.ts"]}
